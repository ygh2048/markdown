# 一些面试问题

## volitate,const，static和extern
### volatite
- 禁止优化，强制内存访问
- 在程序外修改变量
- 不保证线程安全

### const
- 定义可修改的常量或限制修改
- 定义常量或不可修改的变量/函数参数/成员函数

### static
- 控制存储期或作用域  
- 类成员
- 静态变量

### extern
- 访问其他文件中的全局变量
- 在头文件中声明全局变量
- C++中调用C函数
- 定义可跨文件访问的const
- extern 不能用于局部变量
- extern不能喝static一起用



### 补充
volatite const 修饰：
用于只读硬件寄存器，限制程序对寄存器的更改，但是其内容可能会被硬件改变。
同于：
- 只读硬件寄存器，如状态寄存器，配置寄存器
- 多线程/中断共享的只读数据。如全局配置
- 固件/ROM数据，可能被外部更新

## 静态函数/变量
static修饰    
### C语言
- 局部静态变量
  - 生命周期为整个程序运行过程
  - 只在声明其的函数中可见
  - 在函数调用后不会重新被初始化
- 全局静态变量
  - 仅限与定义它的源文件内部可见
  - 用于避免命名冲突
  - 正常全局变量可以使用extern访问，静态全局变量使用extern也无法访问
- 静态函数
  - 仅限与定义它的源文件可见
  - 避免命名冲突

### CPP
- 类的静态成员函数
  - 不依赖类的实例，可以直接通过类名调用
  - 只能访问类的静态成员变量
  - 没有this指针
- 类的静态成员变量
  - 被类的所用对象共享
  - 必须在类外单独定义和初始化
  - 不依赖任何类对象而存在

## 引用和指针的区别
- 引用是一个对象的别名
  - 一旦初始化就不能改变绑定的对象
  - 不能为空
  - 没有多级引用
  - 安全
- 指针是一个存储对象地址的变量
  - 可以改变存储的地址
  - 可以为空
  - 存在多级指针
  - 不安全

## 常量指针和指针常量   
`int const *p1` const在前，为常量指针   

`int *const p2` const在后，为指针常量

常量指针： 指向的地址可以变，但是不能重新赋值
指针常量： 指向的地址不能变，但是可以改变内容

## 宏定义和内联函数
- 宏定义
  - 预处理器指令，在编译前文本替换
  - 没有类型检查
  - 用于
    - 定义常量
    - 简单的代码扩展
    - 条件编译
- 内联函数
  - 编译器指令，是函数
  - 有类型检查
  - 会在函数调用处直接嵌入函数体，这个取决于编译器是否决定内联
  


## 宏定义和typedef
- 宏定义可以替换任何文本
- typedef是专门为类型创建别名
  - 与struct union enum结合
  - 声明指针比较直观自然

## 声明 定义 初始化

- 声明
  - 告诉编译器 这个东西存在，名字和类型是什么
  - 解决编译时的依赖关系，允许在使用变量/函数后再定义它
- 定义
  -  是声明的具体实现，让编译器创建这个东西
  -  解决连接时的问题，一个变量/函数只能有一个定义
  -  会分配内存，变量在.data  .bss  栈上，函数则是对应的机器指令
-  初始化
   -  在定义的同时或之后，给变量赋予一个初始值
   -  初始化本身不分配内存，是在已经分配好的内存中写入数据


## 堆和栈的对比
### 栈
- 编译器自动分配和释放
- 函数/程序结束自动释放
- 空间较小，依赖与系统
- 分配速度较快，无内存碎片
- 向低地址增长
- 每个线程独占栈

### 堆
- 程序员手动分配（malloc/free）
- free后才释放
- 空间较大
- 分配速度慢，可能产生内存碎片
- 向着高地址增长
- 全局共享，需要同步机制

## C语言编译过程
- 预处理
  - 展开头文件
  - 宏替换
  - 条件编译
  - 删除注释
  - 行标记
- 编译
  - 词法分析
  - 语法分析
  - 语义分析
  - 中间代码生成与优化
  - 代码生成 - 汇编
- 汇编
  - 将汇编代码转换成机器码
- 链接
  - 地址与空间分配
  - 符号解析
  - 重定位
  - 合并库文件
## 数组和指针
### 数组
本质是是一块连续的内存空间，用于存储多个同类型的数据  
声明时必须指定大小  
通常在编译时或栈上分配固定大小的内存    
数组名是一个常量，不能改变    
void func(int arr[]) 完全等价于 void func(int *arr)。

函数内部无法通过sizeof 得到数组真实大小   


### 指针
是一个变量，其值是对另一个对象的内存地址      
指针变量本身是在栈上，但是可以指向任何地方    




## 结构体的大小，地址关系

## 什么是内存泄漏
指的是系统因为某些原因无法释放不在使用的内存，导致这部分内存无法被系统回收利用，从而造成系统内存的浪费    


就是malloc()/new() 后要记得free(),delete()
## NULL / nullptr的使用
在C语言中 NULL本质上是一个整形常量0 ，又是被强制类型转换为void*类型
(void*)0

在C++11 及以上    引入nullptr

只能使用nullptr表示空指针，使用NULL容易导致导致二义性（比如函数重载）

## 对比一下队列和栈
队列是FIFO,先进先出
一个入口一个出口
需要维护两个指针
栈是LILO,后进先出
只能栈顶出入
只需要维护一个指针

变体
- 双端队列
  - 两端都可以出队入队
- 优先队列
  - 优先级高的先出列
  - 堆实现
- 循环队列
## 函数调用的过程
函数A调用函数B
1. 暂停A的执行
2. 保存A的当前状态到内存中-调用栈（压入栈顶）
3. 为B分配栈空间
4. CPU控制权转移到B
5. B执行完毕（return）
6. 销毁B的栈帧
7.  从栈中恢复A的状态
8.  调回A中当初调用B之后的位置开始执行

# knowledge
## 引用和指针
### 引用
引用是已存在变量的别名
引用本身不占用额外的存储空间，它只是绑定在目标对象身上；
`int& ref = var;ref = 10;等价于var = 10;`
### 指针
本质是一个变量，存储了另一个变量或对象的内存地址

`int * ptr; ptr = &var;int x = *ptr;`
## 详解函数
程序运行中，函数主要存在两个内存区域：
- 代码段
  > 位于内存中的只读区域，是编译后的机器指令
  > 程序启动后会加载到固定内存地址，所有函数共享同一代码段，大小在编译时就确定，运行时不变
- 栈
  > 运行时动态分配的内存区域,是函数调用的活动记录，（栈帧）
  > 每个函数调用创建单独的栈帧，存储参数，局部变量，返回地址等等
  > 后进先出 

### 调用执行过程
1. 调用前，参数压栈，返回地址（下一条指令地址）压栈
2. 调用时，创建栈帧，保存当前基址寄存器，设置新基址，局部变量分配
3. 函数返回，返回值准备，栈帧销毁，返回调用点



## 强制类型转换

- 许多情况下C会自动进行隐式转换，不需要显式强制转换
- 将浮点数转换为整数时会丢弃小数部分
- 将较大类型转换为较小类型可能导致数据截断

## 不同指针的区别
### 整型指针和字符指针的区别

在C语言中，整型指针(`int*`)和字符指针(`char*`)虽然都是指针类型，但在多个方面有重要区别：


char* 和int*都是四个字节    


#### 指向的数据类型不同

- **整型指针(int*)**：指向整型数据(`int`类型)
- **字符指针(char*)**：指向字符数据(`char`类型)



#### 指针算术运算的步长不同

- `int*`指针加1时，地址增加`sizeof(int)`(通常4字节)
- `char*`指针加1时，地址增加`sizeof(char)`(总是1字节)

```c
int arr[3] = {1, 2, 3};
int *int_p = arr;
char *char_p = (char *)arr;

int_p++;  // 地址增加4字节(指向arr[1])
char_p++; // 地址增加1字节(指向第二个字节)
```

#### 4. 内存访问粒度不同

- `int*`通常按4字节(32位系统)或8字节(64位系统)访问内存
- `char*`按单字节访问内存

#### 5. 常见用途不同

- **int***：
  - 用于操作整型数组
  - 数值计算
  - 作为通用指针(在某些情况下)

- **char***：
  - 字符串处理
  - 内存操作(因为可以逐字节访问)
  - 二进制数据处理

#### 6. 字节序影响

字符指针常用于检测系统字节序：

```c
int num = 0x12345678;
char *p = (char *)#

if (*p == 0x78) {
    printf("小端序\n");
} else {
    printf("大端序\n");
}
```

## 结构体的地址大小与内存对齐
### 原因
CPU以子长为单位访问内存，而不是以字节为单位访问。   

### 对齐规则

- 偏移规则 结构体成员中的每个成员的起始地址，必须是该成员自身大小与编译器默认对齐模数两者中较小者的整数倍 
- 大小规则 整个结构体的总大小，必须是所有成员中最大对齐模数的整数倍，如果不是，需要在结构体末尾填充字节
- 嵌套规则 如果结构体包含另外一个结构体，则该成员的对齐模数是其内部最大成员的大小

### 常见类型大小


char: 一个字节    
int: 四个字节 
long:四个/八个字节
void*:四个/八个字节 
float:四个字节  
double:八个字节 

### 优化技巧
合理安排结构体成员顺序，从小到大排列或者从大到小排列，可以减少填充字节  

## 数组与指针的区别
指针会有一个专门的地址来存放指针的值，而指针的值又是指针指向元素的地址。    


### 数组名，和数组值
- 数组名  ： 是一个编译器符号，运行时不占用存储空间来存储一个地址值，会直接被编译器解析为数组首元素的地址




# code

## 递归的写法

### 条件
两个基本条件：
- 存在递归终止条件，当满足这个条件的时候，递归不在继续，避免无限递归的栈溢出
- 每次递归都更接近终止条件

### 编写递归函数三要素
 
- 确定函数返回值和传入参数
- 确定递归终止条件
- 确定单层递归的逻辑


## 字符串函数及其用法
**头文件**：`#include <cstring>`  
**注意**：操作以`\0`结尾的`char`数组，需手动管理内存

| 函数        | 用法示例                          | 说明                                |
|-------------|-----------------------------------|-------------------------------------|
| `strlen`    | `int len = strlen(str);`          | 获取字符串长度                      |
| `strcpy`    | `strcpy(dest, src);`              | 复制字符串（需确保`dest`足够大）    |
| `strncpy`   | `strncpy(dest, src, n);`          | 复制最多`n`个字符                   |
| `strcat`    | `strcat(dest, src);`              | 字符串拼接（需确保`dest`足够大）    |
| `strncat`   | `strncat(dest, src, n);`          | 拼接最多`n`个字符                   |
| `strcmp`    | `if (strcmp(s1, s2) == 0) {...}`  | 字符串比较（返回0表示相等）         |
| `strncmp`   | `strncmp(s1, s2, n);`             | 比较前`n`个字符                     |
| `strchr`    | `char* p = strchr(s, 'a');`       | 查找字符首次出现位置                |
| `strrchr`   | `char* p = strrchr(s, 'a');`      | 查找字符最后出现位置                |
| `strstr`    | `char* p = strstr(s, "sub");`     | 查找子串位置                        |
| `strtok`    | `char* tok = strtok(s, ",");`     | 分割字符串（非线程安全）            |




---
# 跳转链接
[点这里跳转list](../list.md)